# 事务

事务是一个不可分割的数据库操作序列，要么完全地执行，要么完全地不执行，是数据库并发控制的基本单位

通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠

一个逻辑工作单元要成为事务，必须满足所谓的 ACID 属性

- 原子性 Atomicity：原子性是指事务包含的所有操作要么全部成功，要么全部失败

- 一致性 Consistency：一致性规定了事务提交前后，永远只可能存在事务提交前的状态和事务提交后的状态，不可能出现中间的过程态

- 隔离性 Isolation：当多个用户开启事务并发操作同一张表时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间

- 持久性 Durability：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作

在 MySQL 中，事务支持是在引擎层实现的

## 并发操作带来的一致性问题

数据库事物无非两种：读取事物、修改事物

在没有事务隔离控制的时候，多个事务在同一时刻对同一数据的操作可能就会影响到最终期望的结果，通常有四种情况：

- 脏写：一个事务的更新覆盖了另一个事务还没提交的更新。事务 A和 B 读入同一数据并修改，B 提交的结果破坏了 A 提交的结果，导致 A 的修改被丢失

- 脏读：一个事务读取了另一个事物未提交的数据。事务 A 修改某一数据，并将其写回磁盘，事务 B 读取同一数据后，A 由于某种原因被撤销，这时 A 已修改过的数据恢复原值，B 读到的数据就与数据库中的数据不一致，则 B 读到的数据为脏数据

- 不可重复读：一个事务两次读取同一个数据，两次读取的数据不一致。事务 A 读取某一数据后，事务 B 对其作了修改，当事务 A 再次读取数据时，得到与前一次不同的值。事务 A 按一定的条件从数据库中读取了某些数据后，事务 B 删除了其中部分记录，当 A 再次以相同条件读取时，发现某些记录消失了

- 幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据

与脏读不一样的是，幻读和不可重复读都是读取了另一条已经提交的事务。

幻读和不可重复读的区别是，不可重个数据项，而幻读针对的是一批数据整体

## 事务隔离等级

同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰

- 未提交读 READ UNCOMMITTED：最低的隔离级别，一个事务在提交之前，对其他事务是可见的，即事务可以读取未提交的数据。该隔离等级存在脏读问题

- 提交读 READ COMMITTED：事务在提交之前，对其它事务是不可见的。该隔离等级解决了脏读的问题，但存在不可重复读问题（两次查询的得到的结果可能不同，即可能在查询的间隙，有其他事务提交了修改）

- 可重复读 REPEATABLE READ：默认隔离等级，在同一事务中多次读取的数据是一致的。该隔离等级解决了脏读和不可重复读问题，但存在幻读（在事务两次查询间隙，有其他事务又插入或删除了新的记录）

- 串行化 SERIALIZABLE：通过对每个读的数据行加上共享锁，强制事务串行化执行，即一个事务一个事务挨个来执行。该隔离等级可以解决上述所有问题，隔离级别最高，但牺牲了系统的并发性

可重复读隔离等级通常是通过在事务开始时创建一致性快照或者通过行级锁来实现的。比如，InnoDB 使用多版本并发控制 MVCC，在事务期间读取的是快照数据，所以其他事务的修改不会影响到当前事务的读取，这样同一事务内多次读取同一行数据的结果是一致的，避免了不可重复读。但幻读的问题在于，即使使用了行锁，也无法阻止其他事务插入新的行，因为这些新行之前并不存在，所以不会被锁定。不过，这里可能要看具体的数据库实现，比如 InnoDB 在可重复读级别下通过间隙锁 Gap Lock 来防止幻读，所以可能实际中解决了幻读

## MVCC

MVCC 是一种多版本读写并发控制机制，是 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现 READ COMMIITTED 和 REPEATABLE READ 这两种隔离级别

MVCC 保存了数据在某个时间点的快照，每行数据都存在多个版本，对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以不加锁（除非使用 `SELECT ... FOR UPDATE` 强行加锁）

- 通过 MVCC 可以让读写互相不阻塞，读不相互阻塞，写不阻塞读，这样可以提升数据并发处理能力

- 因为 MVCC 采用了乐观锁的方式，读取数据时不需要加锁，写操作只需要锁定必要的行，从而降低了死锁的概率

- 解决了一致性读的问题，MVCC 都是快照读，只能看到这个时间点之前事务提交更新的结果，不能看到时间点之后事务提交的更新结果

### 事务版本号

每次事务开启前都会从数据库获得一个自增长的事务 ID，可以从事务 ID 判断事务的执行先后顺序

### Undo log

Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到 Undo log 里，当事务进行回滚时可以通过 Undo log 里的日志进行数据还原

- 保证事务进行 rollback 时的原子性和一致性，当事务进行回滚的时候可以用 Undo log 的数据进行恢复

- 通过读取 Undo log 的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本

存储数据表的 B+ 树节点总是只保留最新的数据，而老版本的数据被放在 Undo log 里，并且以指针的形式关联起来，形成一个链表。查询时会在 B+ 树查找后多引入一个链表查询，但是清理废弃数据时会比较简单，只要把 Undo log 找到一个合适的位置一刀切了即可

### 隐藏字段

MySQL 会为每一行真实数据记录添加两三个隐藏的字段，分别为 row_id、transaction_id 和 roll_pointer

- row_id：非必需隐藏字段。如果表中有自定义的主键或者有 Unique 键，就不会添加 row_id 字段，如果两者都没有，MySQL 会自动添加 row_id 字段

- transaction_id：必需隐藏字段。代表这一行数据由哪个事务 id 创建

- roll_pointer：必需隐藏字段。回滚指针，指向这行数据上一个版本在 Undo log 的地址

![01](事务.assets/01.png)

对于事务 id，只有执行 insert/update/delete 才会产生事务 id，只执行 select 则没有事务 id

![02](事务.assets/02.png)

### ReadView 

READ COMMITTED 和 REPEATABLE READ 这两个事务隔离级别都要保证读到的数据是其他事务已经提交的，但是还是有一定的区别，最核心的问题就在于到底可以读取这个数据的哪个版本

ReadView 机制只在 Read Committed 和 Repeatable Read 隔离级别下生效，所以只有这两种隔离级别才有 MVCC

#### ReadView 组成

ReadView 包含四个比较重要的内容：

- m_ids：表示在生成 ReadView 时，系统中活跃的事务 id 集合，这些事务 id 都是未提交事务

- min_trx_id：表示在生成 ReadView 时，系统中活跃的最小事务 id，也就是 m_ids 中的最小值

- max_trx_id：表示在生成 ReadView 时，系统应该分配给下一个事务的 id

- creator_trx_id：表示生成该 ReadView 的事务 id

#### ReadView 用法

有了 ReadView，根据相关信息则可以判断版本信息：

- 如果被访问的版本的 trx_id 和 ReadView 中的 creator_trx_id 相同，就意味着当前版本就是由当前事务创建的，可以读出来

- 如果被访问的版本的 trx_id 小于 ReadView 中的 min_trx_id，表示生成该版本的事务在创建 ReadView 的时候已经提交了，所以该版本可以读出来

- 如果被访问版本的 trx_id 大于或等于 ReadView 中的 max_trx_id 值，说明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被读出来

- 如果生成被访问版本的 trx_id 在 min_trx_id 和 max_trx_id 之间，那就需要判断下 trx_id 在不在 m_ids 中。如果在，说明创建 ReadView 的时候，生成该版本的事务还是活跃的（没有被提交），该版本不可以被读出来。如果不在，说明创建 ReadView 的时候，生成该版本的事务已经被提交了，该版本可以被读出来

- 如果某个数据的最新版本不可以被读出来，就顺着 roll_pointer 找到该数据的上一个版本，继续做如上的判断

#### 更新逻辑

更新数据都是先读后写的，且只能读当前的值，称为当前读

除了 `update` 语句外，`select` 语句如果加锁，也是当前读

#### READ COMMITTED

每次读取数据都会创建 ReadView

#### REPEATABLE READ

事务启动时创建 ReadView，整个事务期间都使用同一个 ReadView

#### 例子

```sql
CREATE TABLE `t` ( 
    `id` int(11) NOT NULL, 
    `k` int(11) DEFAULT NULL, 
    PRIMARY KEY (`id`)
    ) ENGINE=InnoDB;
    
insert into t(id, k) values(1,1),(2,2);
```

![03](事务.assets/03.png)

##### 事务启动时机

`begin/start transaction` 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动

如果想要马上启动一个事务，可以使用 `start transaction with consistent snapshot` 这个命令

##### 结果

事务 C 没有显式地使用 `begin/commit`，表示这个 `update` 语句本身就是一个事务，语句完成的时候会自动提交

事务 B 在更新了行之后查询

事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后

事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1

##### 分析

做如下假设：

- 事务 A 开始前，系统里面只有一个活跃事务 ID 是 99

- 事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务

- 三个事务开始前，(1,1）这一行数据的 transaction_id 是 90

事务 A 的 m_ids 是[99,100]，事务 B 的 m_ids 是[99,100,101], 事务 C 的 m_ids 是[99,100,101,102]

![04](事务.assets/04.png)

第一个有效更新是事务 C

1. 找到 (1, 1)，判断出 transaction_id = 90，小于 102，所以把数据从 (1, 1) 改成了 (1, 2)。这时候这个数据的最新版本的 transaction_id 是 102，而 90 这个版本已经成为了历史版本

第二个有效更新是事务 B

1. 找到 (1,2)，判断出 transaction_id = 102，大于 101，但因为不在事务 B 的 m_ids 中，所以可以把数据从 (1,2) 改成了 (1,3)。这时候这个数据的最新版本 transaction_id 是 101，而 102 又成为了历史版本

事务 A 读数据时，它的 m_ids 是 [99,100]，它的读数据流程：

1. 找到 (1,3) 的时候，判断出 transaction_id = 101，比 100 大，不可见

2. 接着，找到上一个历史版本，transaction_id = 102，比 100 大，不可见

3. 接着，找到上一个历史版本，一看 transaction_id = 90，比99小，可见

当事务 B 要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C 的更新就丢失了，因此，事务 B 此时的 `set k=k+1` 是在（1,2）的基础上进行的操作

在更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据 (1,3)，这个新版本的 transaction_id 是 101；在执行事务 B 查询语句的时候，一看自己的版本号是 101 和最新数据的版本号相同，可以直接使用，所以查询得到的 k 的值是 3

如果把事务 A 的查询语句 select * from t where id=1 修改一下，加上 lock in share mode 或 for update，也都可以读到版本号是 101 的数据，返回的 k 的值是 3

### 拓展

假设事务 C 不是马上提交的，而是变成了下面的事务 C'

![05](事务.assets/05.png)

事务 C' 的不同是，更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了

虽然事务 C' 还没提交，但是 (1,2) 这个版本也已经生成了，并且是当前的最新版本

事务 C' 没提交，也就是说 (1,2) 这个版本上的写锁还没释放。而事务 B 是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C' 释放这个锁，才能继续它的当前读

![06](事务.assets/06.png)
# count 函数分析

在不同的 MySQL 引擎中，`count(*)` 有不同的实现方式

1. MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 `count(*)` 的时候会直接返回这个数，效率很高

2. InnoDB 执行 `count(*)` 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。由于多版本并发控制 MVCC 的原因，InnoDB 表应该返回多少行也是不确定的

假设表 t 中现在有 10000 条记录，三个用户并行操作数据库：

- 会话 A 先启动事务并查询一次表的总行数

- 会话 B 启动事务，插入一行后记录后，查询表的总行数

- 会话 C 先启动一个单独的语句，插入一行记录后，查询表的总行数

![01](count函数分析.assets/01.png)

因为 InnoDB 的主键索引叶子节点存储了完整数据，而非主键索引仅存储索引列的值和主键值，并且普通索引的数据量通常远小于主键索引，因此其 B+ 树的高度更低，占用的磁盘/内存空间更小

对于 `count(*)` 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的，因此 MySQL 优化器会找到最小的那棵树来遍历

普通索引的 B+ 树更小，扫描时需要读取的页更少，减少磁盘 I/O 和内存占用。即使普通索引的叶子节点不包含完整数据，但 `count(*)` 只需统计行数，无需回表获取数据，因此效率更高

## 不同的 count 用法

`count()` 是一个聚合函数，对于返回的结果集，一行行地判断，如果 `count` 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值

对于 `count(主键 id)` 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加

对于 `count(1)` 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字 1 进去，判断是不可能为空的，按行累加

`count(1)` 执行得要比 `count(主键 id)` 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作

按照效率排序的话，`count(字段)` < `count(主键 id)` < `count(1)` ≈ `count(*)`，所以建议尽量使用 `count(*)`
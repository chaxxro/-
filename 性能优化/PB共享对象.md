# PB 共享对象

## 缓存 PB 对象

为了减少对 kv 的请求数，因此在本地使用多阶哈希表作为 local cache

传统 RPC 方式流程：

1. 从网络 IO 拷贝二进制
2. 解压缩二进制
3. 反序列化构造 pb 对象
4. 析构 pb 对象

使用 local cache 流程：

1. 从共享内存拷贝二进制
2. 解压缩二进制
3. 反序列化构造 pb 对象
4. 析构 pb

从上面流程可以看出，使用 local cache 没有降低 CPU 开销，只是降低了下游的负载

针对共享数据，我们的使用方式只是只读，所以完全可以让所有请求获取同一个 pb 的引用，因此 local cache 应该缓存 pb 对象而不是二进制，这样才能避免重复构造、析构 pb 对象

## PB 对象池

反序列化的时候复用被淘汰的 pb，节省的是 pb 构建申请内存的开销。 根据 PB 的官方文档，比较大的结构体对象复用性能优于 areana 优于构造一个新对象并申请内存

对象池的基本原理很简单，全局的容器存储被分配的对象，构造对象的时候从池子中拿，回收对象的时候清空后放回池内

对象池的大坑是内存膨胀，即由于内存复用，每个对象的内存占用都大于其实际大小。所以像内存池有自己的淘汰策略一样，对象池也需要实现自己的淘汰策略
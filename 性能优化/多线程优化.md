# 多线程优化

影响多线程性能的主要因素有以下两个：

 1. Lock Contention
 2. Cache Coherency

## Lock Contention

在多线程环境中，多个线程同时尝试获取同一个锁时，会发生竞争现象

优化的思路就是尽量避免多个线程同时访问同一资源，常见的优化方向有两种：

 1. 减少临界区大小：临界区越小，这段代码的执行时间就越短，从而在整体程序运行时间中所占的比例也越小，冲突也就越少
 2. 对共享资源进行分桶操作：每个线程只会在某个桶上访问资源，理想情况下，每个线程都会访问不同的桶，这样就不会有冲突

## Cache Coherency

由于现代计算机系统通常包含多个处理器，每个处理器都有自己的缓存（如 L1、L2、L3 缓存），因此在并发访问共享内存时，可能会出现缓存数据不一致的问题。缓存一致性协议旨在解决这些问题，确保所有处理器在访问共享内存时看到的是一致的数据

当对一个共享变量进行写入操作时，实际上需要通过缓存一致性协议将该变量的更新同步到其他线程的缓存中，否则可能会读到不一致的值。实际上这个同步过程的单位是一个缓存行（Cache Line），而且同步过程相对较慢，因为涉及到跨核通信

### Cache Ping-Pong

在多处理器系统中，多个处理器频繁地对同一个缓存行进行读写操作，导致该缓存行在不同处理器的缓存之间频繁地来回传递

### False Sharing

在多处理器系统中，多个处理器访问不同的数据，但这些数据恰好位于同一个缓存行中，导致该缓存行在不同处理器的缓存之间频繁传递。尽管处理器访问的是不同的数据，但由于它们共享同一个缓存行，仍然会引发缓存一致性流量，导致性能下降

## 锁和原子操作

锁和原子操作的性能是一个量级的，并不存在 `std::atomic` 一定比` std::mutex` 更快的说法，这其实是因为现代 C++ 中的 `std::mutex` 实现已经高度优化，与上自旋锁非常相似，在低竞争的情况下并不会陷入内核态

`std::atomic` 的优点：

1. 可以实现内存占用极小的锁
2. 当临界区操作可以等价于一个原子操作时，性能会更高
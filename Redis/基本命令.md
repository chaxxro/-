# 基本命令

## 通用

```sh
# 返回类型信息
TYPE key

# 返回内部关联信息
OBJECT REFCOUNT key
# 返回内部编码信息
OBJECT ENCODING key
# 返回内部空闲信息
OBJECT IDLETIME key
# 返回内部频率信息
OBJECT FREQ key

# 检测 key 是否存在
EXISTS key
# 重命名 newkey 存在时覆盖旧值
RENAME key newkey
# 仅当 newkey 不存在时才改名
RENAMENX key newkey
# 查找符合模式的所有 key
KEYS pattern
# 删除
DEL key1 key2...
# 随机获取一个 key
RANDOMKEY

# 设置过期时间，单位秒
EXPIRE key seconds
# 过期时间单位为毫秒
PEXPIRE key milliseconds
# 过期时间点，Unix 时间戳
EXPIREAT key timestamp
PEXPIREAT key milliseconds-timestamp
# 返回剩余时间
TTL key
PTTL key
# 移除过期时间，key 不存在时返回 -2，key 存在但没有设置过期时间返回 -1
PERSIST key

# 以增量迭代的方式扫描数据集，以避免一次性返回大量数据导致的阻塞问题
# cursor：游标，初始值为 0，后续的值由上一次 SCAN 命令返回
# MATCH pattern：用于匹配特定模式的键
# COUNT count：建议每次返回的元素数量，但不保证
SCAN cursor [MATCH pattern] [COUNT count]
# SSCAN 用于迭代遍历 set 中的元素
SSCAN key cursor [MATCH pattern] [COUNT count]
# HSCAN 用于迭代遍历 hash 中的键值对
HSCAN key cursor [MATCH pattern] [COUNT count]
# ZSCAN 用于迭代遍历 sorted set 的元素
ZSCAN key cursor [MATCH pattern] [COUNT count]
# 一个元素，它从遍历开始直到遍历结束期间都存在于被遍历的数据集当中
# 那么 SCAN 命令总会在某次迭代中将这个元素返回给用户
# 同一个元素可能会被返回多次
# 一个元素是在迭代过程中被添加到数据集的，又或者是在迭代过程中从数据集中被删除的
# 那么这个元素可能会被返回，也可能不会

# 对 list、set 和 sorted set 中的元素进行排序
# key：要排序的列表、集合或有序集合的键
# BY pattern：根据指定的模式排序
# LIMIT offset count：用于分页，offset 表示起始位置，count 表示返回的元素数量
# GET pattern：用于获取排序后元素的其他属性
# ASC|DESC：指定排序顺序
# ALPHA：按字典顺序排序，而不是按数值排序
# STORE destination：将排序结果存储到指定的键中，而不是直接返回结果
SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]

# 当前数据库 key 数量
DBSIZE
# 清空
FLUSHDB
# 清空所有数据库数据
FLUSHALL

# 切换数据库
SELECT index
# 交换数据库
SWAPDB db1 db2

# 标记一个事务块的开始
MULTI
# 执行所有事务块内的命令
EXEC
# 取消事务，放弃执行事务块内的所有命令
DISCARD

# 如果 key 处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令
# 那么 EXEC 命令只在 key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断
WATCH key1 key2...
# 取消 WATCH 命令对所有 key 的监视
UNWATCH

# 执行一个同步保存操作，以 RDB 文件的形式保存到硬盘，但会阻塞所有客户端
SAVE
# 后台异步保存当前数据库的数据到磁盘
BGSAVE
# 执行一个 AOF文件 重写操作，只会在没有其他持久化工作在后台执行时被触发
BGREWRITEAOF
```

## bitmap

```sh
# 对 key 所储存的字符串值，设置或清除指定偏移量上的位
SETBTI key offset value
# 当 key 不存在时，自动生成一个新的字符串值

GETBIT key offset
# 当 offset 比字符串值的长度大，或者 key 不存在时，返回 0

# 返回 1 的数量
GETCOUNT key [start] [end]
# key 不存在则为 0

# 返回第一个值为 bit 的位置
BITPOS key bit [start] [end]

# 对多个 key 做并、或、异或、非计算
BITOP AND|OR|XOR|NOT dst key1 key2...
```

## hash

```sh
# 将 hash 表中 filed 设置为 valude
HSET hash field value
# 如果给定的哈希表并不存在， 那么创建一个新的哈希表
# 如果 field 已经存在于哈希表中， 那么它的旧值将被新值覆盖

HGET hash field

HEXISTS hash field

HMSET hash field1 value1 fedld2 value2...
# 会覆盖已存在的 field

HMGET hash field1 field2...

# 哈希表不存在则创建
# field 存在则放弃执行
# field 不存在则执行
HSETNX hash field value

# 删除 hash 中的 field
HDEL hash field1 field2

# 获取 hash 表中 field 数量
HLEN hash

# 获取 hash 表中 field 对应的字符串长度
HSTRLEN hash field

# 为 hash 表中 field 的值加上增量
# 增量可以为负数
HINCRBY hash field num
HINCRBYFLOAT hash field num
# hash 不存在则新建
# field 不存在则初始化为 0

# 获取 hash 中所有的 field
HKEYS hash

# 获取 hash 中所有 value
HVALS hash

# 获取 hash 中所有 field-value
HGETALL hash
```

## set

```
# 将元素添加进集合
SADD key member1 member2...

# 检测元素是否在集合中
SISMEMBER key member

# 返回随机元素
SRANDMEMBER key count
# count 表示返回元素个数

# 移除元素
SREM key member1 member2...

# 移除一个随机元素
SPOP key

# 将 src 元素 member 移动到 dst
SMOVE src dst member
# 如果 src 不存在或 member 不存在则不执行任何操作

# 获取集合元素数量
SCARD key

# 获取集合所有元素
SMEMBERS key

# 获取元素
SSCAN key cursor MATCH pattern count
# cursor 游标，0 代表从头开始遍历
# SSCAN 会返回一个游标，之后可以使用它延续之前的遍历
# pattern 模式匹配
# count 返回元素个数，默认 10

# 交集
SINTER key1 key2...
SINTERSTORE dst key1 key2...
# 将交集保存到 dst
# dst 存在则覆盖

# 并集
SUNION key1 key2...
SUNIONSTORE dst key1 key2

# 差集
SDIFF key1 key2...
SDIFFSTORE dst key1 key2...
```

## sortedset

```
# 添加元素
ZADD key score1 member1 score2 member2...
# 如果 member 已存在则更新 score 并重新排序
# score 可以是整数和双精度浮点数

# 获取权重
ZSCORE key member
# 以字符串形式返回权重

# 获取递增排行
ZRANK key member
# 获取递减排行
ZREVRANK key member

# 获取数量
ZCARD key

# 获取区间个数
ZCOUNT key min max
# 闭区间

# 获取字典序区间个数
ZLEXCOUNT key min max

# 获取区间元素
ZRANGE key start stop [WITHSCORES]
# 返回成员按 score 递增排序
# 相同 score 按字典排序

# 获取字典序元素
ZRANGEBYLEX key min max [LIMIT offset count]
# 对元素使用 memcmp() 和 min/max 做比较

# 递减输出
ZREVRANGE key start stop [WITHSCORES]

# 获取区间元素
ZRANGEBYSCORE key min max [WITHSCORES][LIMIT offset count]
# min 可以是 -inf
# max 可以是 +inf
# 默认闭区间，可用 ( 表示开区间
ZREVRANGEBYSCORE key min max [WITHSCORES][LIMIT offset count]

# 权重操作
ZINCRBY key increment member
# member 的 score 加上增量 increment
# increment 可以是负数
# member 不存在时，权重默认为 0

# 移除
ZREM key member1 member2...
# member 不存在则忽略

# 按排行移除
ZREMRANGEBYRANK key start stop
# 按权重移除
ZREMRANGEBYSCORE key start stop
# 字典序移除
ZREMRANGEBYLEX key min max

# 使用游标获取元素
ZSCAN key cursor MATCH pattern count

# 并集
ZUNIONSTORE dst numkeys key1... [WEIGHTS weight...] [AGGREGATE SUM|MIN|MAX]
# 给定 key 的数量必须以 numkeys 参数指定
# 默认结果集中某个成员的 score 值是所有给定集下该成员 score 值之和
# WEIGHTS 为每个集合权重赋值惩罚因子，默认为 1 
# AGGREGATE 指定聚合方式

# 交集
ZINTERSTORE dst numkeys key1... [WEIGHTS weight...] [AGGREGATE SUM|MIN|MAX]
```

## stream

```
# 插入一条消息
XADD key id field0 value0...
# id 为 * 表示让 Redis 为插入的数据自动生成一个全局唯一的 id
# 也可以直接在消息队列名称后自行设定一个 id 号，只要保证这个 id 号是全局唯一的就行
# 生成的消息的全局唯一 id 由两部分组成

# 获取总长度
XLEN key

# 范围获取
XRANGE key start end [COUNT count]
XREVRANGE key start end [COUNT count]
# - + 表示获取所有，- 表示最小 ID， + 表示最大 ID

# 删除消息
XDEL key id
# 仅设置标志位，不影响消息总长度

# 删除 Streams
del key

# 获取消息
XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]
# milliseconds 用于设置 XREAD 为阻塞模式下阻塞时长，默认为非阻塞模式
# BLOCK 0 代表永远阻塞
# ID，用于设置由哪个消息开始读取
# 使用 0 表示从第一条消息开始
# 消息队列 ID 是单调递增的，所以通过设置起点，可以向后读取
# 在阻塞模式中，可以使用 $，表示最新的消息 ID
# 如果有多个客户端等待同一个队列，当队列添加一个新消息的时候
# 所有客户端都会收到这个消息，策略为 FIFO

# 创建消费者组
XGROUP CREATE key group-name id
# id 为 $ 表示从新消息开始分发，0 表示从头开始分发
# 初始化 last_delivered_id

# 组内消费
XREADGROUP GROUP group-name consumer-name [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]
# count：读取数量
# milliseconds：阻塞时间
# ID 为 > 表示从组内 last_delivered_id 后面开始读
# ID 为 0-0 表示读取所有 PEL 消息及 last_delivered_id 之后的新消息

# 组内消费确认
XACK key group-name id
```

## hyperloglog

```
# 添加
PFADD key element1...

# 获取近似基数
PFCOUNT key1...

# 合并
PFMERGE dst key1...
```